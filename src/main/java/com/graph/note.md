### 图的表示方式
- 邻接矩阵
  > 利用与顶点数相等行列的矩阵表示，两个顶点如果连通值为权重，否则为无穷大。
- 邻接表法
  > 记录每个结点的邻居结点，可采用链表、HashMap来表示。
### 图结构
```java
Graph{
        HashMap<Integer, Node> nodes;
        HashSet<Edge> edges;
        }
```
```java
Node {
    int value; // 结点值
    int in; // 入度
    int out; // 出度
    ArrayList<Node> nexts; // 当前结点邻结点
    ArrayList<Edge> edges; // 当前节点邻接边
}
```
```java
Edge {
    int weight; // 权重
    Node from; // 出发
    Node to; // 结尾
}
```
###图算法
- TIPS
> 在练习题目的时候一般会把题目的图转换为自己习惯的结构，按平时的算法结题。
- 宽度优先遍历
> 需要使用队列结构，并且需要一个集合将用于记录访问情况（图可能存在回路，可能无法完成宽度遍历）。
- 深度优先遍历
> 使用栈结构，一条路径走到底，无法走通则按栈返回，同样访问过的结点需要进行记录。
- 拓扑排序
> 入读为0的结点优先遍历，遍历后与此节点相关度入度减一，重复步骤即可得到拓扑序列。
> 拓扑排序的应用广泛例如编译时依赖编译顺序，判断图是否存在环等。
> 知识点1:x出发能走过的所有点如果大于y出发能够走过的所有点则 x的拓扑排序一定在Y的前面。可以据此得到拓扑排序
> 知识点2:如果x出发走过的最大深度大于y,则拓扑排序x一定在y前面。
- 最小生成树
> 定义:保证所有结点都联通的情况下，求权重和最小的树。
> K算法:排序边，如果边形不形成环则加入结果集，否则不加入结果。(并查集)
> P算法:任意节点出发不会影响最小树的生成。从一个结点出发，解锁其直接边，在所有边中选取一个最小值，加入结果集。此时会有新的边解锁，选取最小，直到所有的点被加入结果集。
- Dijkstra